#!/bin/bash

LOGFILE="/var/log/auth.log"
THRESHOLD=5
WINDOW_MINUTES=5

echo "Running SSH compromise detection..."

# Get current time in seconds
CURRENT_TIME=$(date +%s)

# Extract failed attempts in last 5 minutes
FAILED_IPS=$(sudo grep -a "Failed password" $LOGFILE | while read line; do
    LOG_TIME=$(echo "$line" | awk '{print $1}')
    LOG_SECONDS=$(date -d "$LOG_TIME" +%s 2>/dev/null)
    if [ ! -z "$LOG_SECONDS" ]; then
        DIFF=$(( (CURRENT_TIME - LOG_SECONDS) / 60 ))
        if [ "$DIFF" -le "$WINDOW_MINUTES" ]; then
            echo "$line"
        fi
    fi
done | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | sort | uniq -c)

# Process each IP
echo "$FAILED_IPS" | while read count ip; do
    if [ "$count" -gt "$THRESHOLD" ]; then
        
        # Check for successful login from same IP
        SUCCESS=$(sudo grep -a "Accepted password" $LOGFILE | grep "$ip")
        
        if [ ! -z "$SUCCESS" ]; then
            echo "$(date) CRITICAL: SSH brute-force succeeded from $ip ($count failed attempts)" >> ssh_security_alerts.log
            echo "CRITICAL: SSH brute-force succeeded from $ip"
        else
            echo "$(date) WARNING: SSH brute-force detected from $ip ($count failed attempts)" >> ssh_security_alerts.log
            echo "WARNING: SSH brute-force detected from $ip"
        fi
    fi
done

1ï¸âƒ£ Shebang + Variables
#!/bin/bash

Tells Linux: execute this script using the Bash shell.

LOGFILE="/var/log/auth.log"
THRESHOLD=5
WINDOW_MINUTES=5

These are configuration variables.

â€¢ LOGFILE â†’ where SSH authentication logs live
â€¢ THRESHOLD â†’ how many failed attempts trigger alert
â€¢ WINDOW_MINUTES â†’ time window for detection

This makes the script reusable. You can change detection sensitivity without rewriting logic.

2ï¸âƒ£ Informational Output
echo "Running SSH compromise detection..."

Just prints a status message so you know it started.

3ï¸âƒ£ Get Current Time in Seconds
CURRENT_TIME=$(date +%s)

This is critical.

date +%s gives Unix epoch time (seconds since 1970).

Why?

Because comparing timestamps as text is messy.
Comparing numbers (seconds) is clean.

Example:

2026-02-20T05:32:43
â†’ 1771555963 (epoch)

Now we can subtract times mathematically.

4ï¸âƒ£ Extract Failed Attempts

This is the heart of the script:

FAILED_IPS=$(sudo grep -a "Failed password" $LOGFILE | while read line; do

Step 1:
Search auth.log for lines containing:

Failed password

Each match is piped into a loop:

while read line

Now we process each failed login individually.

4Aï¸âƒ£ Extract Timestamp
LOG_TIME=$(echo "$line" | awk '{print $1}')

This grabs the first column (timestamp).

Example log:

2026-02-20T05:32:43 ubuntu-Victim sshd[1124]: Failed password for ubuntu from 192.168.100.10

Field $1 = timestamp.

4Bï¸âƒ£ Convert to Seconds
LOG_SECONDS=$(date -d "$LOG_TIME" +%s 2>/dev/null)

This converts timestamp into epoch seconds.

If conversion fails, it suppresses error output.

4Cï¸âƒ£ Time Difference Calculation
DIFF=$(( (CURRENT_TIME - LOG_SECONDS) / 60 ))

We subtract:

Current time âˆ’ log time

Then divide by 60 â†’ convert to minutes.

Now we know:

â€œHow many minutes ago did this event happen?â€

4Dï¸âƒ£ Apply Time Window Filter
if [ "$DIFF" -le "$WINDOW_MINUTES" ]; then
    echo "$line"
fi

If event occurred within last 5 minutes, keep it.

If older â†’ ignore it.

This is time-based filtering logic.

Very important in SOC detection.

5ï¸âƒ£ Extract IPs + Count

After the loop finishes, this runs:

grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | sort | uniq -c

Breakdown:

â€¢ grep -oE â†’ extract only IP addresses
â€¢ sort â†’ group identical IPs
â€¢ uniq -c â†’ count occurrences

Result looks like:

8 192.168.100.10

That means 8 failures from that IP in last 5 minutes.

This entire result is stored inside:

FAILED_IPS
6ï¸âƒ£ Process Each IP
echo "$FAILED_IPS" | while read count ip; do

Now we loop through each IP + its failure count.

Example:

count=8
ip=192.168.100.10
7ï¸âƒ£ Apply Threshold Logic
if [ "$count" -gt "$THRESHOLD" ]; then

If failures > 5 â†’ suspicious.

Now correlation begins.

8ï¸âƒ£ Check For Successful Login
SUCCESS=$(sudo grep -a "Accepted password" $LOGFILE | grep "$ip")

This searches:

Did the same IP later have:

Accepted password

If yes â†’ attacker eventually guessed correct password.

9ï¸âƒ£ Severity Classification

If success found:

CRITICAL: SSH brute-force succeeded

If only failures:

WARNING: SSH brute-force detected

This is alert severity mapping.

Real SOC logic.

ðŸ”Ÿ Logging the Alert
>> ssh_security_alerts.log